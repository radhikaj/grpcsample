// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#include <stdio.h>

// Include the trusted helloworld header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the helloworld.edl file.
#include "helloworld_t.h"
//#include "hello.pb.h"
#include <iostream>
#include <memory>
#include <string>


#include <grpcpp/grpcpp.h>

#include "helloworld.grpc.pb.h"
using grpc::Server;
using grpc::ServerBuilder;
using grpc::ServerContext;
using grpc::Status;
using helloworld::HelloRequest;
using helloworld::HelloReply;
using helloworld::Greeter;

#include <cstdlib>
#include <cstring>
#include <functional>
#include <map>
#include <thread>
#include <vector>
#include <atomic>


#ifndef _OE_INTERNAL_PTHREADHOOKS_H
#define _OE_INTERNAL_PTHREADHOOKS_H

#include <openenclave/bits/defs.h>
#include <openenclave/bits/result.h>
#include <pthread.h>





#ifndef _THREAD_ARGS_H
#define _THREAD_ARGS_H

#include <atomic>
#include <mutex>

const uint64_t MAX_ENC_KEYS = 16;

class atomic_flag_lock
{
  public:
    void lock()
    {
        while (_flag.test_and_set())
        {
            continue;
        }
    }
    void unlock()
    {
        _flag.clear();
    }

  private:
    std::atomic_flag _flag = ATOMIC_FLAG_INIT;
};

typedef std::unique_lock<atomic_flag_lock> atomic_lock;

#endif /* _THREAD_ARGS_H */

OE_EXTERNC_BEGIN
typedef struct _oe_pthread_hooks
{
    int (*create)(
        pthread_t* thread,
        const pthread_attr_t* attr,
        void* (*start_routine)(void*),
        void* arg);

    int (*join)(pthread_t thread, void** retval);

    int (*detach)(pthread_t thread);
} oe_pthread_hooks_t;

void oe_register_pthread_hooks(oe_pthread_hooks_t* pthread_hooks);

OE_EXTERNC_END

#endif /* _OE_INTERNAL_PTHREADHOOKS_H */

static std::vector<std::function<void*()>> _thread_functions;
static uint64_t _next_enc_thread_id = 0;
static uint64_t _enc_key = 0; // Monotonically increasing enclave key

// Map of enc_key to thread_id returned by pthread_self()
static std::map<uint64_t, pthread_t> _key_to_thread_id_map;

static atomic_flag_lock _enc_lock;

struct thread_args
{
    uint64_t enc_key;
    int join_ret;
    int detach_ret;
};
// Each new thread will point to memory created by the host after thread
// creation
thread_args _thread_args[MAX_ENC_KEYS];

static int _pthread_create_hook(
    pthread_t* enc_thread,
    const pthread_attr_t*,
    void* (*start_routine)(void*),
    void* arg)
{
    *enc_thread = 0;
    uint64_t enc_key;
    {
        atomic_lock lock(_enc_lock);
        _thread_functions.push_back(
            [start_routine, arg]() { return start_routine(arg); });
        enc_key = _enc_key = ++_next_enc_thread_id;
        printf("_pthread_create_hook(): enc_key is %lu\n", enc_key);
        // Populate the enclave key to thread id map in advance
        _key_to_thread_id_map.insert(std::make_pair(enc_key, *enc_thread));

        if (_next_enc_thread_id > (MAX_ENC_KEYS - 1))
        {
            printf(
                "Exceeded max number of enclave threads supported %lu\n",
                MAX_ENC_KEYS - 1);
        }
    }

    // Send the enclave id so that host can maintain the map between
    // enclave and host id
    if (OE_OK != host_create_thread(enc_key, oe_get_enclave()))
    {
        printf(
            "_pthread_create_hook(): Error in call to host_create_pthread "
            "for enc_key=%lu\n",
            enc_key);
        oe_abort();
    }

    // Block until the enclave pthread_id becomes available in the map
    while (*enc_thread == 0)
    {
        {
            atomic_lock lock(_enc_lock);
            *enc_thread = _key_to_thread_id_map[enc_key];
        }
        if (*enc_thread == 0)
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(20));
        }
    }

    printf(
        "_pthread_create_hook(): pthread_create success for enc_key=%lu; "
        "thread id=%#10lx\n",
        _enc_key,
        *enc_thread);

    return 0;
}

static int _pthread_join_hook(pthread_t enc_thread, void**)
{
    // Find the enc_key from the enc_thread
    uint64_t join_enc_key;
    {
        atomic_lock lock(_enc_lock);
        std::map<uint64_t, pthread_t>::iterator it = std::find_if(
            _key_to_thread_id_map.begin(),
            _key_to_thread_id_map.end(),
            [&enc_thread](const std::pair<uint64_t, pthread_t>& p) {
                return p.second == enc_thread;
            });
        if (it == _key_to_thread_id_map.end())
        {
            printf(
                "_pthread_join_hook(): Error: enc_key for thread ID %#10lx not "
                "found\n",
                enc_thread);
            oe_abort();
        }

        join_enc_key = it->first;
        _thread_args[join_enc_key - 1].enc_key = join_enc_key;
    }

    printf(
        "_pthread_join_hook(): enc_key for thread ID %#10lx is %ld\n",
        enc_thread,
        join_enc_key);

    int join_ret = 0;
    if (host_join_thread(&join_ret, join_enc_key) != OE_OK)
    {
        printf(
            "_pthread_join_hook(): Error in call to host host_join_pthread for "
            "enc_key=%ld\n",
            join_enc_key);
        oe_abort();
    }

    {
        atomic_lock lock(_enc_lock);
        _thread_args[join_enc_key - 1].join_ret = join_ret;

        // Since join succeeded, delete the _key_to_thread_id_map
        if (!join_ret)
        {
            _key_to_thread_id_map.erase(join_enc_key);
        }
    }

    return join_ret;
}

static int _pthread_detach_hook(pthread_t enc_thread)
{
    // Find the enc_key from the enc_thread
    uint64_t det_enc_key;
    {
        atomic_lock lock(_enc_lock);
        std::map<uint64_t, pthread_t>::iterator it = std::find_if(
            _key_to_thread_id_map.begin(),
            _key_to_thread_id_map.end(),
            [&enc_thread](const std::pair<uint64_t, pthread_t>& p) {
                return p.second == enc_thread;
            });
        if (it == _key_to_thread_id_map.end())
        {
            printf(
                "_pthread_detach_hook(): Error: enc_key for thread ID %#10lx "
                "not found\n",
                enc_thread);
            oe_abort();
        }

        det_enc_key = it->first;
        _thread_args[det_enc_key - 1].enc_key = det_enc_key;
    }

    printf(
        "_pthread_detach_hook(): enc_key for thread ID %#10lx is %ld\n",
        enc_thread,
        det_enc_key);

    int det_ret = 0;
    if (host_detach_thread(&det_ret, det_enc_key) != OE_OK)
    {
        printf(
            "_pthread_detach_hook(): Error in call to host host_detach_thread "
            "for enc_key=%ld\n",
            det_enc_key);
        oe_abort();
    }

    // Since detach succeeded, delete the _key_to_thread_id_map
    if (0 == det_ret)
    {
        atomic_lock lock(_enc_lock);
        _key_to_thread_id_map.erase(det_enc_key);
    }

    return det_ret;
}

// Launches the new thread in the enclave
void enc_enclave_thread(uint64_t enc_key)
{
    _thread_args[_enc_key - 1].enc_key = enc_key;
    _thread_args[_enc_key - 1].join_ret = -1;
    _thread_args[_enc_key - 1].detach_ret = -1;

    std::function<void()> f;

    {
        atomic_lock lock(_enc_lock);
        _key_to_thread_id_map[enc_key] = pthread_self();
    }

    std::this_thread::yield();

    {
        atomic_lock lock(_enc_lock);
        f = _thread_functions.back();
        _thread_functions.pop_back();
    }
    f();
}

void  setuphooks()
{
    static oe_pthread_hooks_t _hooks = {.create = _pthread_create_hook,
                                        .join = _pthread_join_hook,
                                        .detach = _pthread_detach_hook};
    
    oe_register_pthread_hooks(&_hooks);
}


#ifdef __cplusplus
extern "C"
{
#endif
#include <poll.h>
#include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>
#include <unistd.h>
#include <sys/eventfd.h>
  #include <sys/socket.h>
       #include <netinet/in.h>
       #include <arpa/inet.h>
       int pipe(int pipefd[2])
       {
       return 0;
       }
       int socketpair(int domain, int type, int protocol, int sv[2])
       {
       return 0;
       }
        int gethostname(char *name, size_t len)
        {
        return 0;
        }
        ssize_t writev(int fd, const struct iovec *iov, int iovcnt)
        {
        return 0;
        }
        
       ssize_t recvfrom(int socket, void *__restrict buffer, size_t length,
       int flags, struct sockaddr *__restrict address,
       socklen_t *__restrict address_len)
       {
       return 0;
       }
int poll(struct pollfd *fds, nfds_t nfds, int timeout)
{
  return 0;
}

int epoll_create(int size);int epoll_create1(int flags)
{
  return 0;
}

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)
{
  return 0;
}
int epoll_wait(int epfd, struct epoll_event *events,
              int maxevents, int timeout)
              {
                return 0;
              }
                      
                       



ssize_t read(int fd, void *buf, size_t count)
{
  return 0;
}

       off_t lseek(int fd, off_t offset, int whence)
       {
         return 0;
       }

   ssize_t write(int fd, const void *buf, size_t count)
   {
     return 0;
   }
  
  const char *gai_strerror(int ecode)
  {
    abort();
    return nullptr;
  }

  ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)
  {
    return 0;
  }

  ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags)
  {
    return 0;
  }
 int getifaddrs(struct ifaddrs **ifap)
 {
   return 0;
 }

       void freeifaddrs(struct ifaddrs *ifa)
       {
         return ;
       }
int fcntl(int fd, int cmd, ... /* arg */ )
{
  return 0;
}
 int inet_pton(int af, const char *src, void *dst)
 {
   return 0;
 }
  
       const char *inet_ntop(int af, const void *src,
                             char *dst, socklen_t size)
                             {
                               return NULL;
                             }


in_addr_t inet_addr(const char *cp)
{
  return 0;
}

       int ioctl(int fd, unsigned long request, ...)
       {
         return 0;
       }
       
       

#include <unistd.h>

int unlink(const char *path)
{
return 0;
}                      

struct tm *localtime(const time_t *t)
{
        static struct tm tm;
        //return localtime_r(t, &tm);
        return nullptr;
}




#ifdef __cplusplus
}
#endif


// Logic and data behind the server's behavior.
class GreeterServiceImpl final : public Greeter::Service {
  Status SayHello(ServerContext* context, const HelloRequest* request,
                  HelloReply* reply) override {
    std::string prefix("Hello ");
    reply->set_message(prefix + request->name());
    return Status::OK;
  }
};


int ecall_run(const char *input,
    uint64_t input_len,
    char **output,
    uint64_t max_len,
    uint64_t *output_len)
{


    //hello_world::HelloOutput enclave_output;
    //hello_world::HelloInput enclave_input;
    //std::string str("Hello");

/*
    printf("In Enclave");
    if (!enclave_input.ParseFromArray(input, input_len)) {
        printf("Could not parse input from array\n");
        return 1;
    }
    str = str + " " + enclave_input.to_greet();

    enclave_output.set_greeting_message(str);
    *output = (char*)oe_host_malloc(max_len);
    if (!enclave_output.SerializeToArray(*output, enclave_output.ByteSize()))
    {
        return 1;
    }
    *output_len = enclave_output.ByteSize();
*/
  setuphooks();
  printf("Hellofrom enclave\n");
  std::string server_address("0.0.0.0:50051");
  GreeterServiceImpl service;
  ServerBuilder builder;
  // Listen on the given address without any authentication mechanism.
  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
  // Register "service" as the instance through which we'll communicate with
  // clients. In this case it corresponds to an *synchronous* service.
  builder.RegisterService(&service);
  // Finally assemble the server.
  std::unique_ptr<Server> server(builder.BuildAndStart());
  std::cout << "Server listening on " << server_address << std::endl;

  // Wait for the server to shutdown. Note that some other thread must be
  // responsible for shutting down the server for this call to ever return.
  server->Wait();

    return 0;
}
